<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://unpkg.com/nes.css/css/nes.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="src/conway.css" />
    <title>Jeu à deux</title>
    <style>
      .remaining-blocks {
        margin: 10px 0;
        font-size: 1.1em;
        display: flex;
        justify-content: space-around;
      }

      .remaining-blocks div {
        padding: 5px 10px;
        border-radius: 5px;
        background-color: #f0f0f0;
      }
    </style>
  </head>
  <body>
    <main class="nes-container is-rounded">
      <h1>Jeu à deux</h1>
      <div id="status" class="nes-text"></div>
      <div id="gameArea" style="display: none">
        <div class="game-container">
          <div class="game-header">
            <h1>Conway's Game of Life - Multiplayer</h1>
            <div id="player-turn">Player 1's Turn</div>
            <div class="remaining-blocks">
              <div>
                Joueur 1: <span id="player1-blocks">10</span> pions restants
              </div>
              <div>
                Joueur 2: <span id="player2-blocks">10</span> pions restants
              </div>
            </div>
          </div>

          <div id="grid-container"></div>

          <div class="generation-input">
            <div class="player-input">
              <h3>Player 1 - Generations</h3>
              <input type="number" id="player1-generations" min="1" max="100" />
              <div id="player1-timer" class="timer">30</div>
            </div>
            <div class="player-input">
              <h3>Player 2 - Generations</h3>
              <input type="number" id="player2-generations" min="1" max="100" />
              <div id="player2-timer" class="timer">30</div>
            </div>
          </div>

          <div id="game-result" class="hidden">
            <h2 id="winner-announcement"></h2>
            <div id="player-scores"></div>
          </div>

          <button id="reset-game">Reset Game</button>
        </div>
      </div>
    </main>
    <!-- script websocket -->
    <script>
      const ws = new WebSocket("ws://localhost:8090/game/");
      const statusDiv = document.getElementById("status");
      const gameArea = document.getElementById("gameArea");
      let myPlayerNumber = null;
      let game;

      ws.onopen = function () {
        statusDiv.textContent = "Connexion établie. Recherche d'un joueur...";
      };

      ws.onmessage = function (event) {
        const data = JSON.parse(event.data);
        console.log("Message reçu:", data);

        switch (data.type) {
          case "game_start":
            statusDiv.textContent = data.message;
            gameArea.style.display = "block";
            myPlayerNumber = data.player_number;
            game = new Conway();
            break;

          case "game_update":
            console.log("Mise à jour du jeu:", data.game_data);
            game.jsonGame = data.game_data;
            game.currentPlayer = data.current_player;
            game.syncGridWithJSON();
            game.updateTurnDisplay();
            break;

          case "waiting":
            statusDiv.textContent = data.message;
            break;
        }
      };

      ws.onclose = function () {
        statusDiv.textContent = "Connexion fermée.";
        gameArea.style.display = "none";
      };

      ws.onerror = function (error) {
        console.error("Erreur WebSocket :", error);
        statusDiv.textContent = "Une erreur est survenue.";
      };
    </script>
    <!-- script conway -->
    <script>
      class Conway {
        constructor(gridSize = 20) {
          this.gridSize = gridSize;
          this.jsonGame = {
            player1: [],
            player2: [],
          };
          this.currentPlayer = 1;
          this.playerBlocks = { 1: 0, 2: 0 };
          this.generation = 0;
          this.initializeGrid();
          this.syncGridWithJSON();
          this.updateBlocksDisplay();
        }

        initializeGrid() {
          const gridContainer = document.getElementById("grid-container");
          gridContainer.style.gridTemplateColumns = `repeat(${this.gridSize}, 20px)`;
          gridContainer.innerHTML = "";

          for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
              const cell = document.createElement("div");
              cell.classList.add("cell");
              cell.dataset.row = i;
              cell.dataset.col = j;
              cell.addEventListener("click", () => this.toggleCell(i, j));
              gridContainer.appendChild(cell);
            }
          }
        }

        toggleCell(row, col) {
          if (this.currentPlayer !== myPlayerNumber) return;
          if (this.playerBlocks[this.currentPlayer] >= 10) return;

          const cell = document.querySelector(
            `.cell[data-row="${row}"][data-col="${col}"]`
          );

          if (!cell.classList.contains("alive")) {
            cell.classList.add("alive", `player${this.currentPlayer}`);

            // Mise à jour du JSON
            const position = [row, col];
            const playerKey = `player${this.currentPlayer}`;

            // Vérifier si la position n'existe pas déjà
            if (
              !this.jsonGame[playerKey].some(([r, c]) => r === row && c === col)
            ) {
              this.jsonGame[playerKey].push(position);
              this.playerBlocks[this.currentPlayer]++;
              this.updateBlocksDisplay();

              console.log("JSON après placement:", this.jsonGame);
              ws.send(JSON.stringify(this.jsonGame));
            }
          }
        }

        switchPlayer() {
          this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        }

        updateTurnDisplay() {
          const turnDisplay = document.getElementById("player-turn");
          turnDisplay.textContent = `Player ${this.currentPlayer}'s Turn`;
        }

        syncGridWithJSON() {
          console.log("Synchronisation avec JSON:", this.jsonGame);

          // Réinitialise les compteurs de blocs
          this.playerBlocks = { 1: 0, 2: 0 };

          // Réinitialise toutes les cellules
          document.querySelectorAll(".cell").forEach((cell) => {
            cell.classList.remove("alive", "player1", "player2");
          });

          // Parcours du JSON pour activer les cellules
          for (const [player, positions] of Object.entries(this.jsonGame)) {
            const playerNumber = player === "player1" ? 1 : 2;
            const playerClass = `player${playerNumber}`;

            // Met à jour le compteur de blocs pour ce joueur
            this.playerBlocks[playerNumber] = positions.length;

            positions.forEach(([row, col]) => {
              const cell = document.querySelector(
                `.cell[data-row="${row}"][data-col="${col}"]`
              );
              if (cell) {
                cell.classList.add("alive", playerClass);
              }
            });
          }

          this.updateBlocksDisplay();
          console.log("Blocs après sync:", this.playerBlocks);
        }

        resetGame() {
          if (
            this.jsonGame.player1.length > 0 ||
            this.jsonGame.player2.length > 0
          ) {
            return;
          }

          this.jsonGame = { player1: [], player2: [] };
          this.currentPlayer = 1;
          this.playerBlocks = { 1: 0, 2: 0 };

          this.syncGridWithJSON();
          document.getElementById("game-result").classList.add("hidden");
          this.updateTurnDisplay();
          this.updateBlocksDisplay();

          ws.send(JSON.stringify(this.jsonGame));
        }

        runGenerations(generations) {
          // Récupérer l'état actuel depuis la grille
          const currentState = {
            player1: [],
            player2: [],
          };

          // Parcourir toutes les cellules pour reconstruire l'état
          document.querySelectorAll(".cell").forEach((cell) => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (cell.classList.contains("player1")) {
              currentState.player1.push([row, col]);
            } else if (cell.classList.contains("player2")) {
              currentState.player2.push([row, col]);
            }
          });

          // Mettre à jour this.jsonGame avec l'état actuel
          this.jsonGame = currentState;

          console.log("Début des générations avec état:", this.jsonGame);

          // Vérifier s'il y a des cellules vivantes
          if (
            this.jsonGame.player1.length === 0 &&
            this.jsonGame.player2.length === 0
          ) {
            console.log(
              "Pas de cellules vivantes pour commencer les générations"
            );
            return;
          }

          let currentGen = 0;
          const generationInterval = setInterval(() => {
            if (currentGen >= generations) {
              clearInterval(generationInterval);
              this.endGame();
              return;
            }

            console.log(`Génération ${currentGen + 1}`);
            this.calculateNextGeneration();
            currentGen++;
          }, 1000);
        }

        calculateNextGeneration() {
          console.log("Début calculateNextGeneration");
          console.log("État initial:", JSON.stringify(this.jsonGame));

          const newState = { player1: [], player2: [] };
          const gridState = Array(this.gridSize)
            .fill()
            .map(() => Array(this.gridSize).fill(0));

          // Marquer les cellules existantes dans la grille
          ["player1", "player2"].forEach((player, index) => {
            this.jsonGame[player].forEach(([row, col]) => {
              if (
                row >= 0 &&
                row < this.gridSize &&
                col >= 0 &&
                col < this.gridSize
              ) {
                gridState[row][col] = index + 1;
              }
            });
          });

          // Calculer la prochaine génération
          for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
              const currentPlayer = gridState[row][col];
              const neighbors = this.countLiveNeighborsFromGrid(
                gridState,
                row,
                col
              );

              if (currentPlayer !== 0) {
                // Règle de survie
                if (neighbors === 2 || neighbors === 3) {
                  newState[`player${currentPlayer}`].push([row, col]);
                }
              } else if (neighbors === 3) {
                // Règle de naissance
                const dominantPlayer = this.getDominantPlayerFromGrid(
                  gridState,
                  row,
                  col
                );
                newState[`player${dominantPlayer}`].push([row, col]);
              }
            }
          }

          console.log("Nouvel état calculé:", newState);
          this.jsonGame = newState;
          this.syncGridWithJSON();
          ws.send(JSON.stringify(this.jsonGame));
        }

        countLiveNeighborsFromGrid(grid, row, col) {
          let count = 0;
          for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
              if (i === 0 && j === 0) continue;

              const newRow = row + i;
              const newCol = col + j;

              if (
                newRow >= 0 &&
                newRow < this.gridSize &&
                newCol >= 0 &&
                newCol < this.gridSize
              ) {
                if (grid[newRow][newCol] !== 0) {
                  count++;
                }
              }
            }
          }
          return count;
        }

        getDominantPlayerFromGrid(grid, row, col) {
          const counts = { 1: 0, 2: 0 };

          for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
              if (i === 0 && j === 0) continue;

              const newRow = row + i;
              const newCol = col + j;

              if (
                newRow >= 0 &&
                newRow < this.gridSize &&
                newCol >= 0 &&
                newCol < this.gridSize
              ) {
                const player = grid[newRow][newCol];
                if (player !== 0) {
                  counts[player]++;
                }
              }
            }
          }

          return counts[2] > counts[1] ? 2 : 1;
        }

        endGame() {
          const player1Cells = this.jsonGame.player1.length;
          const player2Cells = this.jsonGame.player2.length;

          const winnerAnnouncement = document.getElementById(
            "winner-announcement"
          );
          const playerScores = document.getElementById("player-scores");
          const gameResult = document.getElementById("game-result");

          winnerAnnouncement.textContent =
            player1Cells > player2Cells
              ? "Player 1 Wins!"
              : player2Cells > player1Cells
              ? "Player 2 Wins!"
              : "It's a Tie!";

          playerScores.innerHTML = `
          Player 1: ${player1Cells} cells<br>
          Player 2: ${player2Cells} cells
      `;

          gameResult.classList.remove("hidden");
        }

        // Nouvelle méthode pour mettre à jour l'affichage des pions restants
        updateBlocksDisplay() {
          document.getElementById("player1-blocks").textContent =
            10 - this.playerBlocks[1];
          document.getElementById("player2-blocks").textContent =
            10 - this.playerBlocks[2];
        }
      }
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const game = new Conway();

        document
          .getElementById("reset-game")
          .addEventListener("click", () => game.resetGame());

        const generationInputs = document.querySelectorAll(
          ".generation-input input"
        );

        const submitButton = document.createElement("button");
        submitButton.textContent = "Start Generations";
        submitButton.addEventListener("click", () => {
          const player1Generations =
            parseInt(document.getElementById("player1-generations").value) ||
            null;
          const player2Generations =
            parseInt(document.getElementById("player2-generations").value) ||
            null;

          const avgGenerations =
            player1Generations !== null && player2Generations !== null
              ? Math.floor((player1Generations + player2Generations) / 2)
              : player1Generations || player2Generations || 10;

          game.runGenerations(avgGenerations);
        });

        document.querySelector(".generation-input").appendChild(submitButton);
      });
    </script>
  </body>
</html>
